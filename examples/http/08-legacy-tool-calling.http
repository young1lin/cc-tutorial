# ============================================
# 传统工具调用方法（无 Function Calling）
# ============================================
# 说明：展示在原生 Function Calling 出现之前的工具调用方法
# 历史背景：早期 LLM 不支持原生 FC，通过结构化文本模拟调用
# 目的：理解技术演进，知道"为什么需要 Function Calling"
# ============================================

# 环境变量
@GLM_BASE_URL = https://open.bigmodel.cn/api/coding/paas/v4/chat/completions
@GLM_BEARER_TOKEN = Bearer {{$dotenv GLM_API_KEY}}

# ============================================
# 1. 文本格式 ReAct（LangChain 风格）
# ============================================

### [传统 1.1] 文本格式 ReAct - 基础
# 通过提示词让模型输出 Thought/Action/Action Input 格式文本
# 这是 LangChain 最早的 ReAct 实现方式
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "system",
      "content": "你是一个智能助手，可以使用以下工具：\n\n1. get_weather(location: str) - 获取指定城市的天气\n2. search(query: str) - 搜索信息\n3. calculator(expression: str) - 计算数学表达式\n\n请使用以下格式回答问题：\n\nThought: 你对问题的思考\nAction: 工具名称\nAction Input: 工具输入（JSON 格式）\n\n当你有足够信息后，使用：\n\nThought: 我现在知道最终答案了\nFinal Answer: 最终答案\n\n重要：每次只能执行一个 Action！"
    },
    {
      "role": "user",
      "content": "明天杭州天气怎么样？如果下雨，推荐室内景点。"
    }
  ],
  "model": "GLM-4.7",
  "stream": false,
  "temperature": 0
}

### [传统 1.2] 文本格式 ReAct - 完整 3 轮循环
# 查天气 → 根据天气搜索景点 → 给出最终答案
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "system",
      "content": "你是一个智能助手。工具列表：\n- get_weather(location, date)\n- search(query)\n\n格式：\nThought: ...\nAction: ...\nAction Input: {...}\n\n或：\nThought: 我现在知道答案了\nFinal Answer: ..."
    },
    {
      "role": "user",
      "content": "明天杭州天气怎么样？如果下雨，推荐室内景点。"
    },
    {
      "role": "assistant",
      "content": "Thought: 需要先查天气\nAction: get_weather\nAction Input: {\"location\": \"hangzhou\", \"date\": \"tomorrow\"}"
    },
    {
      "role": "user",
      "content": "Observation: {\"weather\": \"Rainy\", \"temperature\": \"10°C\"}"
    },
    {
      "role": "assistant",
      "content": "Thought: 天气是雨天，需要搜索室内景点\nAction: search\nAction Input: {\"query\": \"杭州室内景点推荐\"}"
    },
    {
      "role": "user",
      "content": "Observation: 杭州室内景点：浙江博物馆、杭州科技馆、西湖音乐喷泉（室内观赏区）、杭州图书馆"
    }
  ],
  "model": "GLM-4.7",
  "stream": false,
  "temperature": 0
}

# ============================================
# 2. XML 格式（Anthropic Claude 早期风格）
# ============================================

### [传统 2.1] XML 格式 - 结构化标签
# Claude 2.x 时期的推荐方式，结构清晰易解析
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "system",
      "content": "你是一个智能助手。当需要使用工具时，请使用以下 XML 格式：\n\n<thinking>你的思考过程</thinking>\n<action>\n  <tool>工具名称</tool>\n  <parameters>\n    <param_name>参数值</param_name>\n  </parameters>\n</action>\n\n可用工具：\n- get_weather：获取天气，参数 location, date\n- search：搜索信息，参数 query\n\n当有最终答案时，使用：\n<answer>你的答案</answer>"
    },
    {
      "role": "user",
      "content": "明天北京天气如何？"
    }
  ],
  "model": "GLM-4.7",
  "stream": false,
  "temperature": 0
}

# ============================================
# 3. JSON 格式（OpenAI 早期方案）
# ============================================

### [传统 3.1] JSON 格式 - 模拟工具调用
# 让模型输出 JSON 字符串，程序解析后执行
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "system",
      "content": "你是一个智能助手。当需要使用工具时，请返回以下 JSON 格式：\n\n{\n  \"thought\": \"你的思考\",\n  \"action\": \"工具名称\",\n  \"action_input\": {\n    \"参数名\": \"参数值\"\n  }\n}\n\n可用工具：\n- get_weather(location, date)\n- search(query)\n- calculator(expression)\n\n当有最终答案时，返回：\n{\n  \"thought\": \"我知道答案了\",\n  \"final_answer\": \"答案内容\"\n}\n\n重要：只返回 JSON，不要包含其他文字！"
    },
    {
      "role": "user",
      "content": "明天杭州天气怎么样？"
    }
  ],
  "model": "GLM-4.7",
  "stream": false,
  "temperature": 0
}

# ============================================
# 4. 对比：传统方法 vs 原生 Function Calling
# ============================================

### [对比 4.1] 传统 ReAct（文本解析）
# 问题：解析复杂易出错、模型可能忘记格式、无法保证结构化
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "system",
      "content": "传统 ReAct：你必须严格按照格式输出！\n\nThought: ...\nAction: ...\nAction Input: {...}\n\n不要有任何额外的话！"
    },
    {
      "role": "user",
      "content": "查询杭州天气"
    }
  ],
  "model": "GLM-4.7",
  "stream": false,
  "temperature": 0
}

### [对比 4.2] 原生 Function Calling（现代方案）
# 优势：标准化接口、模型针对训练、返回结构化 JSON、支持并行
POST {{GLM_BASE_URL}} HTTP/1.1
Content-Type: application/json
Accept: application/json
Authorization: {{GLM_BEARER_TOKEN}}

{
  "messages": [
    {
      "role": "user",
      "content": "查询杭州天气"
    }
  ],
  "model": "GLM-4.7",
  "tools": [
    {
      "type": "function",
      "function": {
        "name": "get_weather",
        "description": "获取指定城市的天气信息",
        "parameters": {
          "type": "object",
          "properties": {
            "location": {"type": "string"}
          },
          "required": ["location"]
        }
      }
    }
  ],
  "stream": false,
  "temperature": 0
}

# ============================================
# 总结
# ============================================
#
# 工具调用的演变：
#   文本 ReAct (2022) → XML (2023) → JSON (2023) → 原生 FC (2024+)
#
# 传统方法的共同问题：
# - 格式不稳定，解析复杂
# - 模型容易忘记格式要求
# - 无类型约束，容易出错
#
# 原生 Function Calling 的优势：
# - 标准化接口，无需手动解析
# - 模型针对性训练，调用更准确
# - 支持并行调用和错误处理
#
# 为什么还要了解传统方法？
# - 理解技术演进和 FC 的设计动机
# - 某些老模型仍需使用传统方法
# - 教学价值：文本格式更直观，便于理解 Agent 原理
# ============================================
