# 第三层：基础操作

# 快捷键

Ctrl + V 只能复制文本
Alt + V 可以复制图片
Ctrl + C 清除当前输入，再次输入，退出应用
Ctrl + O 展开全部内容
Ctrl + T 显示 TODO list
Ctrl + B 将长时间运行的命令移到后台（Claude 稍后用 BashOutput 工具检查结果，不阻塞当前对话）
Ctrl + A 全选并粘贴网页内容（Claude 的 WebFetch 无法访问的页面，比如 Reddit、付费墙内容，直接全选复制粘贴到对话框里）
第一个字符输入 shift + ? 按键，显示所有快捷键
第一个字符输入 ! 直接进入 bash 模式，执行 shell 命令

## 深度思考关键词

在 prompt 中加入特定的关键词，可以触发 Claude 不同深度的推理模式：

- **`think`**：正常深度思考。适合大多数需要推理的任务。
- **`think harder`**：更深层推理。适合复杂的架构决策、多条件的 debug。
- **`ultrathink`**：最深层推理。消耗更多 Token，但对于真正困难的问题（复杂算法、跨模块 bug、并发问题），准确率会显著提升。

这不是什么高级操作，就是在你的 prompt 里加一个词。比如：

```
think harder about this: 我的 WebSocket 连接在高并发下偶尔断开，
已经排查了心跳机制和超时设置，还有什么可能的原因？
```

Claude 会花更多的 Token 去"思考"（实际上是生成更长的推理链），然后给出更深入的分析。

**什么时候用**：复杂架构决策、难以复现的 bug、多条件判断、需要考虑边界情况的算法。

**什么时候不用**：简单的代码修改、格式调整、写注释。不需要每次都 ultrathink，那是浪费 Token。

### Extended Thinking 工作机制（截至 2026 年 2 月）

三个关键词在 Claude Code 内部映射到不同的 thinking budget（思考预算）：

| 关键词 | 触发的思考深度 | 大致 Token 预算 | 适用场景 |
|--------|--------------|----------------|---------|
| `think` | 标准深度思考 | ~4,000 tokens | 常规推理、代码审查、单文件修改 |
| `think harder` | 深层推理 | ~10,000 tokens | 复杂架构决策、多条件 debug、跨文件分析 |
| `ultrathink` | 最大深度推理 | ~32,000 tokens | 极难算法、跨模块并发问题、大规模重构规划 |

> **注意**：2026 年 1 月有报告称 thinking budget 已设置为默认最大值（可通过 Tab 键切换 extended thinking on/off）。上述数值仅供参考，实际行为可能随版本更新而变化。详见 [Claude Code Guide](https://www.claude-code-guide.com/)、[Reddit 讨论](https://www.reddit.com/r/ClaudeAI/comments/1qew64u/rip_to_ultrathink/)。

**计费说明（截至 2026 年 2 月）：**

根据 [Anthropic 官方定价](https://platform.claude.com/docs/en/about-claude/pricing)：

| 模型 | Input | Output |
|------|-------|--------|
| **Opus 4.6** | $5/M tokens | $25/M tokens |
| **Sonnet 4.5** | $3/M tokens | $15/M tokens |

- thinking tokens 按 **output tokens** 费率计费
- 你看到的是压缩后的摘要（`<summary>` 标签内），但实际计费按完整 thinking tokens 计算
- 例：Claude 内部推理用了 8,000 tokens，摘要压缩到 800 tokens 显示给你，**计费仍为 8,000 output tokens**
- thinking tokens **不占后续上下文窗口**——前一轮的 thinking tokens 会被剥离，只保留摘要，不会挤占你宝贵的 200K 上下文

**使用建议：**

- 大多数编码任务 `think` 就够了，不要养成无脑加 `ultrathink` 的习惯
- 仅在复杂度明确很高时使用 `think harder`——比如你已经尝试过一次，Claude 给的方案不够深入
- `ultrathink` 是最后手段，单次可能消耗 $0.5-2+（取决于模型和输出长度）
- 通过 `/cost` 命令查看当前会话的实际消耗，避免盲目使用高级思考
- 如果你用的是 Claude Max 订阅（$100/200 月），thinking tokens 同样计入用量限制

**实际效果对比：**

```
普通问题（"帮我写个排序函数"）
  → 不需要 think，直接问就行

中等问题（"这个 WebSocket 连接为什么偶尔断开？"）
  → think harder about this: 我的 WebSocket 连接在高并发下偶尔断开...

极难问题（"设计一个支持 10 万并发的消息系统的完整架构"）
  → ultrathink: 设计一个支持 10 万并发的消息系统...
```

**注意**：thinking 关键词只是触发词，不是精确控制。Claude 实际的推理深度还受问题本身复杂度、上下文长度等因素影响。同样的 `think` 关键词，简单问题可能只用 2,000 tokens 思考，复杂问题可能用满 10,000 tokens。

## 纯英文提示词

训练的语料，大部分都是英文，你直接用英文去问，得到的答案通常比中文好（编程领域）。能用英文，尽量用英文提问。包括写 SubAgent 的时候，建议使用英文。

# Resume 和 Rewind

使用 /resume 命令，恢复上次对话，使用 /rewind 命令，退回到指定记录的对话（注意，这里会把后面的对话丢弃掉）。我举个例子，U1 -> A1 -> A2 -> U2 -> A3 -> U3 你这个时候，退回到了 U2，A3 和 U3 的内容会被永久丢弃，所以用这个命令需要慎重。U 表示 user，A 表示 assistant。

# Auto Compact 自动压缩上下文

Claude Code 的上下文窗口是有限的（200k Token），对话多了之后会接近上限。这时候有两种处理方式：

**`/compact`（压缩）**：手动触发，Claude 会把之前的对话内容压缩成一段摘要，保留关键信息（文件路径、决策、代码变更），丢弃具体的对话细节。压缩后上下文占用大幅减少，但之前对话的细节（比如你具体说了什么）可能会丢失。Claude Code 也会在上下文接近上限时**自动触发** compact，你会看到提示 "Auto-compacting conversation..."。

**`/clear`（清空）**：直接清空所有上下文，从零开始。适合切换到完全不同的任务时使用。

**什么时候该用哪个？**
- 同一个任务做到一半，上下文快满了 → `/compact`，保留摘要继续
- 任务已经完成，要开始新任务 → `/clear`，干净的上下文效率更高
- 如果你发现 Claude 开始"忘事"或者重复之前的错误 → 考虑 `/clear` 重新开始，把关键信息写到 CLAUDE.md 里

# Context 和 Compact

上下文在第一节已经非常仔细介绍了

## `@` 文件引用 —— 精准指向代码

对话框中直接输入 `@` 再键入路径，Claude Code 会自动把该文件内容注入上下文。

```
参考 @src/services/user.service.ts 的写法，帮我实现 OrderService
```

- 支持 Tab 补全路径（同 shell）
- 支持引用整个目录：`@src/services/`（会把目录下所有文件注入）
- 适合 Few-Shot 场景：让 Claude 先"看懂"一个现有实现，再写新的

注意：引用大目录会快速消耗上下文，只引用必要文件。

Layer 04 的「珠玉在前」小节里有 `@` 的进阶用法。

## 图片/截图支持

Claude Code 支持直接粘贴图片到对话中。快捷键是 `Alt+V`（Windows/Linux）或 `Option+V`（macOS）。

**适用场景：**

- **前端 UI Bug**：截图粘贴，告诉 Claude "这个按钮的间距不对，帮我修"
- **设计稿对比**：截图 Figma 设计稿，让 Claude 对比当前实现和设计稿的差异
- **错误截图**：浏览器控制台的报错截图、终端的错误输出截图
- **架构图理解**：粘贴架构图让 Claude 理解系统设计

配合 Figma MCP 和 Playwright 插件，可以实现完整的前端开发闭环：Figma 获取设计信息 → Claude 编码实现 → Playwright 截图验证 → 对比差异 → 修正。

## 输入队列（持续输入）

**Claude Code CLI 支持在 Claude 思考/执行工具时继续输入**，这些输入会自动入队，下次 Claude 调用工具时自动带上。

```
┌─────────────────────────────────────────────────────────┐
│                   Claude Code CLI                       │
│                                                         │
│  时间线：                                                │
│  ────────────────────────────────────────────────────── │
│  T1: Claude 正在思考...                                 │
│      用户输入: "重点关注性能问题"     ──→ 入队          │
│                                                         │
│  T2: Claude 调用 Read 工具读取文件...                   │
│      用户输入: "还有内存泄漏"          ──→ 入队         │
│                                                         │
│  T3: Claude 调用下一个工具时...                         │
│      队列消息自动带上一起发送                           │
│                                                         │
│  Input Queue:                                           │
│  ┌─────────────────────────────────────────────────┐   │
│  │ 1. "重点关注性能问题"                            │   │
│  │ 2. "还有内存泄漏"                                │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

**实际使用场景**：

1. **补充说明**：Claude 正在分析代码时，你突然想到一个边界条件，直接输入补充
2. **调整方向**：Claude 正在实现方案 A，你发现方案 B 更好，输入"改成方案 B"
3. **追加需求**：Claude 正在修 bug，你输入"顺便把日志也加上"

**注意**：
- 队列消息会在 Claude **下一次 API 调用**时带上，不是立即生效
- 如果 Claude 已经完成回复，队列消息会在下一轮对话开始时发送
- 这个特性让你不需要等 Claude 完全执行完再输入，提高交互效率
